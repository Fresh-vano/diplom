\newsection
\section{Технический проект}
\subsection{Общие сведения о программной системе}

Необходимо спроектировать и разработать веб-платформу для анализа и визуализации статистических данных киберспортивной игры Counter-Strike 2.

Разрабатываемая программная система предназначена для предоставления комплексного инструмента анализа данных, который позволит игрокам, тренерам и аналитикам изучать подробную статистику матчей, улучшая таким образом свои стратегии и игровые навыки. Платформа предоставит интерактивный пользовательский интерфейс для визуализации данных, позволяя пользователям глубоко погружаться в аналитику матчей.

Основной принцип работы системы заключается в обработке .dem файлов матчей CS2 для извлечения детальных игровых метрик и последующем представлении их через графики, диаграммы и интерактивные отчеты. Пользователи смогут просматривать прогнозы на матч и статистику, такую как точность стрельбы, K/D Ratio, использование гранат и прочее, чтобы оценить силу команды и принять обоснованные решения.

Одним из ключевых компонентов программной системы является база данных для хранения извлеченной статистики матчей и команд. Кроме того, будет реализован функционал машинного обучения для предоставления прогнозов исходов матчей, основанных на исторических данных.

Целью разработки данной программной системы является создание эффективного инструмента анализа данных в киберспорте, который поможет повысить конкурентоспособность игроков и команд на международной арене, способствуя развитию киберспорта как спортивной дисциплины.


\subsection{Проектирование архитектуры программной системы}
\subsubsection{Выбор архитектурного стиля и паттернов проектирования}
Для разработки веб-платформы анализа и визуализации статистических данных CS2 был выбран микросервисный подход. Такой стиль архитектуры подразумевает разбиение функционала системы на отдельные сервисы, каждый из которых отвечает за свою узкоспециализированную задачу. Это обеспечивает гибкость в развертывании и масштабировании, упрощает поддержку и обновление компонентов системы без необходимости внесения изменений во все сервисы сразу, а только в конкретный.

В качестве центрального входа в систему будет использоваться \textbf{API Gateway Pattern}, что позволит унифицировать обработку входящих запросов, распределение нагрузки, обеспечение безопасности и предоставление единой точки входа для клиентских приложений.

Для взаимодействия с клиентами будет использоваться \textbf{REST API}, что гарантирует легкость интеграции и стандартизированное общение между сервисами. REST API идеально подходит для микросервисной архитектуры за счет своей бесшовной и эффективной коммуникации. А так же возможностью предоставления внешнего взаимодействия с сервером.

Все данные, передаваемые между клиентом и сервером, будут защищены с использованием \textbf{HTTPS}, обеспечивая конфиденциальность, целостность передачи данных и защиту от муждуузловых атак.

Для запросов к данным со стороны клиента будет применяться протокол \textbf{OData}, который позволяет стандартизировать выборку, фильтрацию и пагинацию данных через HTTP запросы, обеспечивая гибкость и удобство в интеграции с различными клиентскими приложениями.

Для повышения производительности и снижения нагрузки на базу данных будет использоваться подход \textbf{Cache-Aside} в сочетании с \textbf{Redis}. Это позволит хранить часто запрашиваемые данные в быстром кеше, что существенно ускорит время их доставки конечному пользователю.

Для асинхронного обмена сообщениями между различными микросервисами в системе будет применяться \textbf{RabbitMQ}. Этот брокер сообщений позволит надежно обрабатывать задачи в фоновом режиме, улучшая производительность и масштабируемость системы, обеспечивая отказоустойчивость и балансировку нагрузки при высоких объемах обмена данными.

Данная архитектура обеспечивает всей системе необходимую гибкость для развития и масштабирования, а также повышает надежность и отказоустойчивость приложения при больших нагрузках.

Архитектура всей системы представлена на рисунке \ref{fig:-architecture}.
\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{"images/Архитектура"}
	\caption{Архитектура программной системы}
	\label{fig:-architecture}
\end{figure}

\subsubsection{Структура базы данных}

Основной базой данных для хранения данных в системе будет выступать \textbf{PostgreSQL}. Эта СУБД была выбрана за её надежность, масштабируемость и поддержку сложных запросов, что является критически важным для аналитических запросов, связанных с большими объемами данных. PostgreSQL будет использоваться для хранения всех основных данных системы в SQL формате.

Redis будет использоваться как вспомогательная система для кеширования часто запрашиваемых данных. Это позволит значительно ускорить время отклика системы, уменьшить нагрузку на основную базу данных и предоставить пользователям актуальную информацию с минимальной задержкой. Redis должна использоваться для кеширования данных в формате ключ-значение, где ключом будет выступать хеш объекта, а значением сам данный объект.

\subsubsection{Описание микросервисов}

Веб-платформа будет включать в себя следующие микросервисы:

\begin{itemize}
	\item \textbf{API Gateway:} Является точкой входа в систему, маршрутизирует запросы к соответствующим сервисам. Связан со всеми сервисами.
	\item \textbf{Сервис поиска информации о турнирах:} Отвечает за предоставление актуальных данных о киберспортивных турнирах. Сервис взаимодействует с базой данных и API сторонних платформ для обновления и поддержания в актуальном состоянии информации о предстоящих и прошедших турнирах.
	\item \textbf{Сервис анализа .dem файла:} Загружает и анализирует загруженные .dem файлы, извлекает из матча основные статистические данные для добавления их в базу данных и обработки другими сервисами.
	\item \textbf{Сервис предоставления данных:} Управляет предоставлением данных для разных разделов. Сервис взаимодействует с базой данных для получения, обработки и отправки информационных и статистических данных в нужном формате.
	\item \textbf{Сервис поиска:} Реализует функциональность поиска по всем сегментам данных платформы. Интегрирован с другими сервисами и предоставляет пользователю удобный поиск по игрокам, командам и турнирам.
	\item \textbf{Сервис прогнозирования:} Использует машинное обучение и алгоритмы прогнозирования для предсказания исходов матчей. Анализирует исторические данные и текущие тенденции для генерации прогнозов.
	\item \textbf{Брокер сообщений (RabbitMQ):} Обеспечивает надежную передачу сообщений между сервисами, поддерживает распределенные транзакции и асинхронное взаимодействие в микросервисной архитектуре.
	\item \textbf{Prometheus:} Используется для мониторинга работы сервисов, сбора метрик и уведомления о проблемах, позволяя оперативно реагировать на сбои и изменения в работе системы.
\end{itemize}

\subsubsection{Планирование докеризации и оркестрации сервисов}

Для достижения высокой отказоустойчивости, удобства в развертывании и эффективного масштабирования, развертывание каждого микросервиса веб-платформы будет выполнено в контейнере Docker. Каждый контейнер в себе будет включать требуемое ядро системы, используемые библиотеки и настройки окружения для запуска данного микросервиса. Это позволит обеспечить изоляцию зависимостей между частями платформы и согласованность окружений независимо от инфраструктуры развертывания.

Оркестрация контейнеров будет производиться с помощью Kubernetes, что гарантирует автоматизацию развертывания, масштабирования и управления приложениями контейнеров. Kubernetes обеспечивает балансировку нагрузки, самовосстановление сервисов при их ошибках, автоматическое распределение ресурсов и управление конфигурацией.

Вся инфраструктура веб-платформы будет развернута в облаке Yandex Cloud, что обеспечит высокую доступность сервисов и возможности простой интеграции с другими облачными сервисами.

\subsection{Обоснование выбора технологий проектирования и программных средств}
\subsubsection{Выбор используемых технологий и языков программирования}

\paragraph{API Gateway}

Для реализации данного микросервиса должен быть выбран язык C\# с библиотекой Ocelot для реализации шлюзов и перенаправлений запросов API.

\paragraph{Сервис поиска информации о турнирах}

Для реализации данного микросервиса должен быть выбран язык C\# с использованием библиотек AutoMapper - для реализации мапинга считываемых сущностей из открытых источников и преобразования их в сущности используемые внутри системы, Entity Framework Core - для реализации работы с базами данных, используя объектноориентированный подход, Newtonsoft.Json - для преобразования получаемых JSON файлов в сущности DTO.

\paragraph{Сервис поиска информации о турнирах}

Для реализации данного микросервиса должен быть выбран язык Go, так как он предлагает высокую производительность и эффективность в обработке и анализе низкоуровневых данных, таких как  бинарные файлы .dem записей матчей, благодаря своим встроенным средствам для параллельной обработки. Так же должна использоваться библиотека demoinfocs-golang - библиотека для разбора и анализа .dem файлов игры Counter-Strike 2.

\paragraph{Сервис предоставления данных}

Для реализации данного микросервиса должен быть выбран язык C\# с использованием библиотек Entity Framework Core - для реализации работы с базами данных, AutoMapper - для реализации мапинга сущностей из базы данных в сущности DTO (Data Transfer Object) отправляемые на frontend часть веб-платформы.

\paragraph{Сервис поиска}

Для реализации данного микросервиса должен быть выбран язык C\# с использованием библиотек Entity Framework Core - для реализации работы с базами данных и библиотеки AutoMapper - для реализации мапинга сущностей из базы данных в сущности DTO (Data Transfer Object) отправляемые на frontend часть веб-платформы.

\paragraph{Сервис прогнозирования}

Для реализации данного микросервиса должен быть выбран язык Python из-за его превосходной поддержки библиотек машинного обучения и аналитики данных. Для данного модуля должны использоваться библиотека sklearn - для подготовки датасета для обучения нейронной сети, tensorflow - для непосредственно создания нейронной сети и ее обучения.

\paragraph{Брокер сообщений (RabbitMQ)}

Для реализации взаимодействия между микросервисами через брокер сообщений будет использоваться RabbitMQ. Для работы с RabbitMQ должен быть выбран язык C\# с библиотекой RabbitMQ.Client, предоставляющей удобный API для взаимодействия с RabbitMQ.

\paragraph{Prometheus}

Для мониторинга и алертинга инфраструктуры будет использоваться Prometheus. Он позволит собирать метрики с различных сервисов и узлов, а также устанавливать алерты на основе собранных данных. В микросервисах на C\# для экспорта метрик в Prometheus должна использоваться библиотека prometheus-net.

\paragraph{React}

React - это JavaScript библиотека, разработанная компанией Facebook, предназначенная для создания пользовательских интерфейсов веб-приложений. Она позволяет разрабатывать динамические и интерактивные веб-страницы, обладающие высокой производительностью и масштабируемостью.

Одной из ключевых особенностей React является использование компонентного подхода к созданию интерфейса. Приложение строится из небольших и независимых компонентов, каждый из которых отвечает за определенную часть пользовательского интерфейса. Это позволяет создавать чистый и упорядоченный код, легко поддерживаемый и расширяемый.

Ещё одним важным преимуществом React является использование виртуального DOM (Document Object Model). React создает виртуальное представление DOM в памяти, которое затем сравнивается с реальным DOM и обновляется только та часть, которая изменилась. Это позволяет увеличить производительность приложения и улучшить пользовательский опыт.
React также предоставляет множество инструментов и библиотек для управления состоянием приложения, маршрутизации, тестирования и других задач. Экосистема React очень развита, что делает его популярным выбором для разработки веб-приложений.

Во время разработки веб-платформы должны быть реализованы следующие компоненты для создания полноценной структуры и выполнения поставленных требований в пункте 2.3 технического задания:
\begin{itemize}
	\item \textbf{Компонент отображения статистики по всем картам отдельного игрока:} этот компонент предназначен для отображения статистики игры отдельного игрока по различным картам. Он должен включать среднюю оценку игрока на карте, количество сыгранных карт,  и средние данные, такие как среднее число убийств и урона за раунд.
	\item \textbf{Таблица игроков команды в матче:} таблица, представляющая собой список всех игроков участвующих в матче с их ключевыми статистическими данными для данного матча. Это может включать K/D/A (убийства/смерти/ассисты), разницу между убийствами и смертями, рейтинг и форму игрока в данном матче, и другие данные.
	\item \textbf{Компонент вывода статистики команд за последние 6 месяцев на всех картах:} компонент, который показывает собранные данные о производительности команды на различных картах за последние полгода. Информация представлена в виде процента побед на отдельных картах, среднее число убийств и урона за раунд и отображение статуса победы в последних 5 играх на каждой карте.
	\item \textbf{Компонент сравнения статистики команд и игроков по основным метрикам:} данный компонент предоставляет сравнительный анализ между командами или игроками, позволяя пользователям видеть различия в ключевых статистических показателях. Может быть полезен для анализа формы команд перед матчами. В нем выбранные для сравнения команды или игроки представлены в виде таблицы со всеми метриками, которые попарно сравниваются и выделяются больший из них.
	\item \textbf{Блок формирования одинаковой структуры для всех используемых блоков в системе:} данный компонент является основой для стандартизации внешнего вида и структуры различных компонентов на сайте. Это помогает в обеспечении консистентности пользовательского интерфейса и улучшает общий пользовательский опыт.
	\item \textbf{Компонент отображения команды со списком игроков:} компонент для отображения команды и списка игроков в команде, включая их аватары, название команды и прочее. Данный компонент используется для предоставления обзора состава команды в матчах или турнирах.
\end{itemize}

\subsubsection{Выбор программного обеспечения}

Разработка веб-платформы для анализа и визуализации статистических данных игры Counter-Strike 2 требует продуманного подхода к выбору аппаратного обеспечения. Основные критерии выбора – масштабируемость, надежность, и производительность системы. В качестве основы для реализации инфраструктуры выбраны современные технологии контейнеризации, оркестрации, управления очередями сообщений и мониторинга: Docker, Kubernetes, RabbitMQ, и Prometheus.

Важным аспектом является решение о запуске всей инфраструктуры в облачной среде, что обеспечивает высокую гибкость, масштабируемость и доступность ресурсов. Облачные сервера Yandex Cloud, на которых будет развернута система, будут работать под управлением операционной системы Linux, что гарантирует стабильность работы и широкие возможности для настройки системы.

\subsubsection{Docker}

Docker предоставляет легковесную и удобную платформу для создания, развертывания и управления контейнерами. Контейнеризация упрощает процесс разработки, тестирования и развертывания приложений, позволяя запускать приложения и их зависимости в изолированных средах. В контексте выбора аппаратного обеспечения это означает возможность оптимизации использования ресурсов и увеличение эффективности за счет развертывания на облачных серверах с поддержкой Docker.

На рисунке \ref{fig:-Docker} представлена архитектура работы Docker.
\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{"images/Docker"}
	\caption{Архитектура работы Docker}
	\label{fig:-Docker}
\end{figure}

Данная архитектура состоит из следующих элементов:
\begin{enumerate}
	\item Infrastructure (Инфраструктура): Это физические серверы или виртуальные машины, на которых развёрнуты контейнеризированные приложения. Инфраструктура предоставляет вычислительные ресурсы, такие как процессор, память, дисковое пространство и сеть.
	\item Host Operating System (Хостовая операционная система): Это операционная система, установленная на инфраструктуре. Она управляет аппаратными ресурсами и предоставляет базовые функции для работы контейнеров.
	\item Docker: Docker — это платформа для контейнеризации, которая позволяет разрабатывать, отправлять и запускать приложения в изолированных контейнерах. Docker использует технологии виртуализации на уровне операционной системы, такие как cgroups и namespaces, для изоляции контейнеров.
	\item Containerized Applications (Контейнеризированные приложения): Это приложения, упакованные в контейнеры Docker. Контейнеры включают все необходимые зависимости, библиотеки и конфигурации для работы приложения, что обеспечивает их портативность и изолированность.
\end{enumerate}

\subsubsection{Redis}

Redis — это база данных, размещаемая в памяти, которая используется, в основном, в роли кеша, находящегося перед другой, «настоящей» базой данных, вроде MySQL или PostgreSQL. Кеш, основанный на Redis, помогает улучшить производительность приложений. Он эффективно использует скорость работы с данными, характерную для памяти, и смягчает нагрузку центральной базы данных приложения, связанную с обработкой следующих данных:
\begin{itemize}
	\item Данные, которые редко меняются, к которым часто обращается приложение.
	\item Данные, не относящиеся к критически важным, которые часто меняются.
\end{itemize}

Примеры таких данных могут включать в себя сессионные кеши или кеши данных, а так же содержимое панелей управления — вроде списков лидеров и отчётов, включающих в себя данные, агрегированные из разных источников.

Рассмотрим, как работает Redis в качестве кеша на основе архитектуры представленной на рисунке \ref{fig:-Redis}.
\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{"images/Redis"}
	\caption{Пример работы Redis}
	\label{fig:-Redis}
\end{figure}

Пример работы при первом обращении к данным:
\begin{enumerate}
	\item Пользователь делает запрос к серверу (Шаг 1)
	\item Сервер проверяет наличие необходимых данных в Redis (Шаг 2).
	\item Если данных в кэше нет, сервер отправляет запрос к основной базе данных (Шаг 3).
	\item Основная база данных обрабатывает запрос и возвращает данные серверу (Шаг 4).
	\item Получив данные от основной базы данных, сервер сохраняет их в Redis для последующих запросов (Шаги 5-6).
	\item После сохранения данных в кеше они отправляются пользователю (Шаг 7).
\end{enumerate}

Пример работы при обращении к уже сохраненным данным в Redis:
\begin{enumerate}
	\item Пользователь делает запрос к серверу (Шаг 1).
	\item Данные находятся в кеше и возвращаются серверу (Шаг 5).
	\item Сервер отправляет данные пользователю (Шаг 7).
\end{enumerate}

Благодаря использованию кеширования удается уменьшить скорость получения данных при их повторном вызове до x10 раз.

\subsubsection{Kubernetes}

Kubernetes является мощной системой для автоматизации развертывания, масштабирования и управления контейнеризированными приложениями. В архитектуре веб-платформы Kubernetes обеспечивает высокую доступность, автоматическое масштабирование и балансировку нагрузки между контейнерами. Для аппаратного обеспечения это подразумевает необходимость в выделенном или облачном сервере с достаточным количеством процессорного времени и оперативной памяти для поддержания кластера Kubernetes.

\subsubsection{RabbitMQ}

RabbitMQ, система управления очередями сообщений, играет ключевую роль в обеспечении асинхронной обработки данных и интеграции различных частей системы. Эффективное использование RabbitMQ позволяет распределить нагрузку, улучшить производительность приложения и обеспечить надежную обработку сообщений. Аппаратное обеспечение должно соответствовать требованиям по пропускной способности и скорости обработки сообщений, что особенно важно при больших объемах данных. Сервер на котором будет находится данный сервис должен быть максимально отказоустойчивым, для исключения лавинного выхода из строя микросервисов.

На рисунке \ref{fig:-RabbitMQ} представлена работа RabbitMQ и системы управления очередями сообщений (message broker) в процессе передачи сообщений от производителя (publisher) к потребителю (consumer). \ref{fig:-RabbitMQ}.
\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{"images/RabbitMQ"}
	\caption{Пример работы RabbitMQ}
	\label{fig:-RabbitMQ}
\end{figure}

Схема состоит из следующих элементов:
\begin{enumerate}
	\item Publisher (Производитель): это модуль, который отправляет сообщения. В данном примере производитель публикует сообщение с ключом маршрутизации (routing key), равным "somekey".	
	\item Exchange (Обменник): обменник принимает сообщения от производителей и маршрутизирует их в очереди на основе ключа маршрутизации. Обменники могут быть разных типов (direct, fanout, topic, headers), что определяет правила маршрутизации сообщений. В данном примере обменник получает сообщение с ключом маршрутизации "somekey" и определяет, в какую очередь его направить.
	\item Queue (Очередь): очередь — это место, где сообщения хранятся до тех пор, пока они не будут получены потребителем. Очереди могут быть долговременными (persistent), чтобы сохраняться при перезапуске сервера RabbitMQ, или временными (transient), которые удаляются при перезапуске. В данном примере сообщение с ключом маршрутизации "somekey" попадает в определенную очередь.
	\item Consumer (Потребитель): потребитель получает сообщения из очереди и обрабатывает их. Потребители могут подтверждать получение сообщений (acknowledgements), чтобы уведомить RabbitMQ, что сообщение было успешно обработано. В данном примере потребитель извлекает сообщение из очереди и выполняет необходимые действия.
\end{enumerate}

\subsubsection{Prometheus}

Prometheus — система мониторинга и оповещения, которая позволяет собирать и анализировать метрики в реальном времени. Использование Prometheus обеспечивает возможность наблюдения за производительностью системы, оптимизации ресурсов и быстрого реагирования на возникающие проблемы. Аппаратное обеспечение должно обладать достаточным объемом хранилища для сбора и хранения данных метрик, а также процессорной мощностью для их обработки.

\subsection{Проектирование пользовательского интерфейса программной системы}
\subsubsection{Макеты пользовательского интерфейса}

На основании требований к пользовательскому интерфейсу, представленных в пункте 2.3 технического задания, был разработан графический интерфейс мобильного приложения, используя React с использованием библиотеки Material UI. Разработанный интерфейс ориентирован на обеспечение легкости в использовании и удобного визуального представления статистических данных.

На рисунке \ref{fig:-teamPage} представлен макет страницы команды.
\begin{figure}
	\centering
	\includegraphics[width=0.95\linewidth]{"images/Страница команды"}
	\caption{Макет страницы команды}
	\label{fig:-teamPage}
\end{figure}

Макет содержит следующие элементы:
\begin{itemize}
	\item Название команды.
	\item Логотип команды.
	\item Статистика команды по картам.
	\item Список матчей команды.
	\item Состав команды.
\end{itemize}

На рисунке \ref{fig:-playerPage} представлен макет страницы игрока.
\begin{figure}
	\centering
	\includegraphics[width=0.95\linewidth]{"images/Страница игрока"}
	\caption{Макет страницы игрока}
	\label{fig:-playerPage}
\end{figure}

Макет содержит следующие элементы:
\begin{itemize}
	\item Никнейм игрока.
	\item Фото игрока.
	\item Статистика игрока по картам.
	\item Список матчей данного игрока.
	\item Основную информацию о игроке.
	\item Прочую статистику игрока.
\end{itemize}

На рисунке \ref{fig:-matchPage} представлен макет страницы матча.
\begin{figure}
	\centering
	\includegraphics[width=0.95\linewidth]{"images/Страница матча"}
	\caption{Макет страницы матча}
	\label{fig:-matchPage}
\end{figure}

Макет содержит следующие элементы:
\begin{itemize}
	\item Турнир и стадию для данного матча.
	\item Счет и названия команд матча.
	\item Основную информацию матча.
	\item Статистику игроков в данном матче по командам.
\end{itemize}

На рисунке \ref{fig:-tournamentPage} представлен макет страницы турнира.
\begin{figure}
	\centering
	\includegraphics[width=0.95\linewidth]{"images/Страница турнира"}
	\caption{Макет страницы турнира}
	\label{fig:-tournamentPage}
\end{figure}

Макет содержит следующие элементы:
\begin{itemize}
	\item Название турнира, логотип его дата.
	\item Список участвующих команд.
	\item Основную информацию турнира.
	\item Список матчей данного турнира.
\end{itemize}
